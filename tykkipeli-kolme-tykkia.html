<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tykkipeli - Kolmen pelaajan taistelu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('kargil.jpg') center/cover, #2a4a6a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #startScreen.hidden {
            display: none;
        }
        #startOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
        }
        #startText {
            position: relative;
            z-index: 1;
            text-align: center;
            color: white;
            padding: 20px;
        }
        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px black;
        }
        p {
            font-size: 14px;
            margin: 8px 0;
            text-shadow: 2px 2px 4px black;
        }
        .clickText {
            margin-top: 40px;
            font-size: 16px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .player1 { color: #00ff00; }
        .player2 { color: #ffff00; }
        .player3 { color: #ff0000; }
        canvas {
            display: block;
            background: #16213e;
        }
        #info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(15,52,96,0.8);
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div id="startOverlay"></div>
        <div id="startText">
            <h1>Tykkipeli - Kolmen pelaajan taistelu</h1>
            <p><strong>N√§pp√§imist√∂:</strong> ‚¨ÜÔ∏è ‚¨áÔ∏è = S√§√§d√§ | V√ÑLILY√ñNTI = Ammu</p>
            <p><strong>Kosketusn√§ytt√∂:</strong> Ved√§ yl√∂s/alas = S√§√§d√§ | Napauta = Ammu</p>
            <p><span class="player1">Pelaaja 1 (Vihre√§)</span> | <span class="player2">Pelaaja 2 (Keltainen)</span> | <span class="player3">Pelaaja 3 (Punainen)</span></p>
            <p class="clickText">ALOITA PELI</p>
        </div>
    </div>
    
    <canvas id="game"></canvas>
    <div id="info"></div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const info = document.getElementById('info');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (game.terrain.length > 0) draw();
        });
        
        let audioCtx = null;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'shoot') {
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'hit') {
                osc.frequency.setValueAtTime(120, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            }
        }
        
        const game = {
            player1: { x: 0, y: 0, angle: -45, power: 25, alive: true },
            player2: { x: 0, y: 0, angle: -90, power: 25, alive: true },
            player3: { x: 0, y: 0, angle: -135, power: 25, alive: true },
            terrain: [],
            trajectories: [],
            projectile: null,
            currentPlayer: 1,
            gameOver: false,
            touchStartY: null,
            touchMoved: false,
            explosion: null
        };
        
        function generateTerrain() {
            // Generoi tykkien sijainnit riitt√§v√§n kaukana toisistaan
            const positions = [];
            const minDistance = canvas.width * 0.25; // V√§hint√§√§n 25% ruudun leveydest√§
            
            // Pelaaja 1 (vasen alue)
            positions.push(canvas.width * 0.1 + Math.random() * canvas.width * 0.1);
            
            // Pelaaja 2 (keskialue)
            let pos2;
            do {
                pos2 = canvas.width * 0.4 + Math.random() * canvas.width * 0.2;
            } while (Math.abs(pos2 - positions[0]) < minDistance);
            positions.push(pos2);
            
            // Pelaaja 3 (oikea alue)
            let pos3;
            do {
                pos3 = canvas.width * 0.75 + Math.random() * canvas.width * 0.15;
            } while (Math.abs(pos3 - positions[0]) < minDistance && 
                     Math.abs(pos3 - positions[1]) < minDistance);
            positions.push(pos3);
            
            game.player1.x = positions[0];
            game.player2.x = positions[1];
            game.player3.x = positions[2];
            
            // Generoi maasto jyrkill√§ vaihteluilla tykkien kohdalla
            game.terrain = [];
            let y = canvas.height * 0.75;
            
            for (let x = 0; x < canvas.width; x += 10) {
                let target = canvas.height * 0.75;
                let roughness = 60; // Peruskarheus
                
                // Lis√§√§ jyrkkyytt√§ tykkien l√§heisyydess√§
                for (let pos of positions) {
                    const distToPlayer = Math.abs(x - pos);
                    if (distToPlayer < 100) {
                        // Hyvin l√§hell√§ tykki√§ - voi olla jyrkk√§√§
                        roughness = 120;
                        const heightVariation = (Math.random() - 0.5) * canvas.height * 0.3;
                        target = canvas.height * 0.6 + heightVariation;
                    }
                }
                
                // Yleinen maastonmuodostus
                if (roughness === 60) {
                    const factor = Math.sin((x / canvas.width) * Math.PI * 3) * canvas.height * 0.2;
                    target = canvas.height * 0.7 + factor;
                }
                
                y += (target - y) * 0.1 + (Math.random() - 0.5) * roughness;
                y = Math.max(canvas.height * 0.2, Math.min(canvas.height * 0.95, y));
                game.terrain.push({ x, y });
            }
            
            game.player1.y = getTerrainHeight(game.player1.x);
            game.player2.y = getTerrainHeight(game.player2.x);
            game.player3.y = getTerrainHeight(game.player3.x);
            
            game.player1.alive = true;
            game.player2.alive = true;
            game.player3.alive = true;
        }
        
        function getTerrainHeight(x) {
            const idx = Math.floor(x / 10);
            if (idx >= game.terrain.length - 1) return game.terrain[game.terrain.length - 1].y;
            const t1 = game.terrain[idx];
            const t2 = game.terrain[idx + 1];
            const ratio = (x - t1.x) / (t2.x - t1.x);
            return t1.y + (t2.y - t1.y) * ratio;
        }
        
        function getPlayerColor(playerNum) {
            switch(playerNum) {
                case 1: return '#00ff00';
                case 2: return '#ffff00';
                case 3: return '#ff0000';
                default: return '#ffffff';
            }
        }
        
        function draw() {
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Terrain
            const grad = ctx.createLinearGradient(0, canvas.height * 0.5, 0, canvas.height);
            grad.addColorStop(0, '#228b22');
            grad.addColorStop(0.5, '#1a6b1a');
            grad.addColorStop(1, '#0d4d0d');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            game.terrain.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();
            
            // Trajectories
            game.trajectories.forEach(t => {
                ctx.strokeStyle = getPlayerColor(t.player) + '40';
                ctx.lineWidth = 2;
                ctx.beginPath();
                t.points.forEach((p, i) => {
                    i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
            });
            
            // Active projectile
            if (game.projectile) {
                ctx.strokeStyle = getPlayerColor(game.currentPlayer) + '80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                game.projectile.trail.forEach((p, i) => {
                    i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                const p = game.projectile;
                ctx.fillStyle = getPlayerColor(game.currentPlayer);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw all cannons
            drawCannon(game.player1, 1);
            drawCannon(game.player2, 2);
            drawCannon(game.player3, 3);
            
            // Explosion
            if (game.explosion) {
                const elapsed = Date.now() - game.explosion.startTime;
                const progress = elapsed / game.explosion.duration;
                
                if (progress >= 1) {
                    game.explosion = null;
                } else {
                    const radius = game.explosion.maxRadius * progress;
                    const alpha = 1 - progress;
                    
                    const expGrad = ctx.createRadialGradient(
                        game.explosion.x, game.explosion.y, 0,
                        game.explosion.x, game.explosion.y, radius
                    );
                    expGrad.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
                    expGrad.addColorStop(0.3, `rgba(255, 150, 0, ${alpha * 0.8})`);
                    expGrad.addColorStop(0.6, `rgba(255, 50, 0, ${alpha * 0.5})`);
                    expGrad.addColorStop(1, `rgba(100, 0, 0, 0)`);
                    
                    ctx.fillStyle = expGrad;
                    ctx.beginPath();
                    ctx.arc(game.explosion.x, game.explosion.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawCannon(player, playerNum) {
            if (!player.alive) return;
            
            const color = getPlayerColor(playerNum);
            const isActive = game.currentPlayer === playerNum && !game.projectile && !game.gameOver;
            
            // Base
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 12, 0, Math.PI * 2);
            ctx.fill();
            
            if (isActive) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 18, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Barrel
            const angle = player.angle * Math.PI / 180;
            const barrelLen = 25;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(
                player.x + Math.cos(angle) * barrelLen,
                player.y + Math.sin(angle) * barrelLen
            );
            ctx.stroke();
            
            // Info
            ctx.fillStyle = color;
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(
                'P' + playerNum + ': ' + Math.round(-player.angle) + '¬∞',
                player.x,
                player.y + 35
            );
        }
        
        function shoot() {
            const p = game['player' + game.currentPlayer];
            if (!p.alive) return;
            
            const angle = p.angle * Math.PI / 180;
            const power = p.power * (0.98 + Math.random() * 0.04);
            const startY = p.y - 15;
            
            game.projectile = {
                x: p.x,
                y: startY,
                vx: Math.cos(angle) * power,
                vy: Math.sin(angle) * power,
                trail: [{ x: p.x, y: startY }]
            };
            
            playSound('shoot');
            updateInfo('Laukaus ammuttu!');
            animate();
        }
        
        function animate() {
            if (!game.projectile) return;
            
            const p = game.projectile;
            p.vy += 0.5;
            p.x += p.vx;
            p.y += p.vy;
            p.trail.push({ x: p.x, y: p.y });
            
            // Check hit opponents
            for (let i = 1; i <= 3; i++) {
                if (i === game.currentPlayer) continue;
                const opp = game['player' + i];
                if (!opp.alive) continue;
                
                const dist = Math.sqrt((p.x - opp.x) ** 2 + (p.y - opp.y + 10) ** 2);
                if (dist < 18) {
                    hit(i);
                    return;
                }
            }
            
            // Check hit terrain
            if (p.x >= 0 && p.x <= canvas.width) {
                if (p.y >= getTerrainHeight(p.x)) {
                    hitGround();
                    return;
                }
            }
            
            // Check out of bounds
            if (p.x < -100 || p.x > canvas.width + 100 || p.y > canvas.height + 100) {
                miss();
                return;
            }
            
            draw();
            requestAnimationFrame(animate);
        }
        
        function hitGround() {
            playSound('hit');
            
            // Create crater
            const craterX = game.projectile.x;
            const craterRadius = 30;
            
            for (let i = 0; i < game.terrain.length; i++) {
                const t = game.terrain[i];
                const dist = Math.abs(t.x - craterX);
                if (dist < craterRadius) {
                    const depth = (craterRadius - dist) / craterRadius * 40;
                    t.y = Math.min(t.y + depth, canvas.height - 20);
                }
            }
            
            // Update cannon heights
            game.player1.y = getTerrainHeight(game.player1.x);
            game.player2.y = getTerrainHeight(game.player2.x);
            game.player3.y = getTerrainHeight(game.player3.x);
            
            game.trajectories.push({ player: game.currentPlayer, points: game.projectile.trail });
            game.projectile = null;
            nextPlayer();
            draw();
        }
        
        function miss() {
            if (game.projectile && game.projectile.trail) {
                game.trajectories.push({ player: game.currentPlayer, points: game.projectile.trail });
            }
            game.projectile = null;
            nextPlayer();
            draw();
        }
        
        function hit(targetPlayer) {
            playSound('explosion');
            
            const opp = game['player' + targetPlayer];
            opp.alive = false;
            
            game.explosion = {
                x: opp.x,
                y: opp.y - 10,
                maxRadius: 60,
                startTime: Date.now(),
                duration: 800
            };
            
            game.trajectories.push({ player: game.currentPlayer, points: game.projectile.trail });
            game.projectile = null;
            
            const animateExplosion = () => {
                draw();
                if (game.explosion) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    checkWinner();
                }
            };
            
            animateExplosion();
        }
        
        function checkWinner() {
            const alive = [];
            if (game.player1.alive) alive.push(1);
            if (game.player2.alive) alive.push(2);
            if (game.player3.alive) alive.push(3);
            
            if (alive.length === 1) {
                game.gameOver = true;
                const winner = alive[0];
                const color = 'player' + winner;
                info.innerHTML = '<span class="' + color + '">Pelaaja ' + winner + ' VOITTI! üí•</span>';
                setTimeout(() => startScreen.classList.remove('hidden'), 1000);
            } else {
                nextPlayer();
            }
        }
        
        function nextPlayer() {
            // Find next alive player
            for (let i = 0; i < 3; i++) {
                game.currentPlayer = (game.currentPlayer % 3) + 1;
                if (game['player' + game.currentPlayer].alive) {
                    updateInfo('Pelaaja ' + game.currentPlayer + ' vuoro');
                    return;
                }
            }
        }
        
        function updateInfo(text) {
            const color = 'player' + game.currentPlayer;
            info.innerHTML = '<span class="' + color + '">' + text + '</span>';
        }
        
        // Keyboard
        document.addEventListener('keydown', e => {
            if (game.projectile || game.gameOver) return;
            const p = game['player' + game.currentPlayer];
            if (!p.alive) return;
            
            if (e.code === 'ArrowUp') {
                e.preventDefault();
                // Player 1 shoots right, Player 2 shoots any direction, Player 3 shoots left
                const minAngle = game.currentPlayer === 1 ? -90 : game.currentPlayer === 2 ? -180 : -180;
                const maxAngle = game.currentPlayer === 1 ? 0 : game.currentPlayer === 2 ? 0 : -90;
                p.angle = Math.max(p.angle - 1, minAngle);
                draw();
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                const minAngle = game.currentPlayer === 1 ? -90 : game.currentPlayer === 2 ? -180 : -180;
                const maxAngle = game.currentPlayer === 1 ? 0 : game.currentPlayer === 2 ? 0 : -90;
                p.angle = Math.min(p.angle + 1, maxAngle);
                draw();
            } else if (e.code === 'Space') {
                e.preventDefault();
                shoot();
            }
        });
        
        // Touch
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (game.projectile || game.gameOver) return;
            game.touchStartY = e.touches[0].clientY;
            game.touchMoved = false;
        });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (game.projectile || game.gameOver || !game.touchStartY) return;
            
            const deltaY = game.touchStartY - e.touches[0].clientY;
            
            if (Math.abs(deltaY) > 5) {
                game.touchMoved = true;
            }
            
            const p = game['player' + game.currentPlayer];
            if (!p.alive) return;
            
            const change = deltaY * 0.1;
            const minAngle = game.currentPlayer === 1 ? -90 : game.currentPlayer === 2 ? -180 : -180;
            const maxAngle = game.currentPlayer === 1 ? 0 : game.currentPlayer === 2 ? 0 : -90;
            
            p.angle = Math.max(minAngle, Math.min(maxAngle, p.angle - change));
            
            game.touchStartY = e.touches[0].clientY;
            draw();
        });
        
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            if (game.projectile || game.gameOver) return;
            
            if (game.touchStartY && !game.touchMoved) {
                shoot();
            }
            
            game.touchStartY = null;
            game.touchMoved = false;
        });
        
        canvas.addEventListener('click', () => {
            if (game.projectile || game.gameOver) return;
            shoot();
        });
        
        // Start game
        function startGame() {
            initAudio();
            game.currentPlayer = 1;
            game.trajectories = [];
            game.projectile = null;
            game.gameOver = false;
            game.explosion = null;
            game.touchStartY = null;
            game.touchMoved = false;
            generateTerrain();
            draw();
            updateInfo('Pelaaja 1 vuoro - aloita!');
            startScreen.classList.add('hidden');
        }
        
        startScreen.addEventListener('click', startGame);
        startScreen.addEventListener('touchend', e => {
            e.preventDefault();
            startGame();
        });
    </script>
</body>
</html>
