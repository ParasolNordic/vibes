<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tankkipeli - Tabletti</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
        }
        
        #info {
            margin-bottom: 10px;
            text-align: center;
        }
        
        #scores {
            display: flex;
            gap: 20px;
            margin-bottom: 5px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .player1-score {
            color: #00FF00;
        }
        
        .player2-score {
            color: #FF5722;
        }
        
        .player3-score {
            color: #2196F3;
        }
        
        #gameCanvas {
            border: 2px solid #333;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            touch-action: none;
        }
        
        #message {
            margin-top: 10px;
            font-size: 16px;
            min-height: 25px;
            color: #FFD700;
        }
        
        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
            align-items: center;
        }
        
        .dpad-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            max-width: 200px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #fff;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            cursor: pointer;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .control-btn.empty {
            visibility: hidden;
        }
        
        .shoot-btn {
            width: 60px;
            height: 60px;
            border: 3px solid #fff;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            touch-action: none;
            cursor: pointer;
            grid-column: 2;
            grid-row: 2;
        }
        
        .shoot-btn:active {
            transform: scale(0.95);
        }
        
        .player1-controls {
            border-color: #00FF00;
        }
        
        .player1-controls .control-btn {
            border-color: #00FF00;
            background: rgba(0, 255, 0, 0.2);
        }
        
        .player1-controls .shoot-btn {
            border-color: #00FF00;
            background: rgba(0, 255, 0, 0.3);
            color: #00FF00;
        }
        
        .player2-controls {
            border-color: #FF5722;
        }
        
        .player2-controls .control-btn {
            border-color: #FF5722;
            background: rgba(255, 87, 34, 0.2);
        }
        
        .player2-controls .shoot-btn {
            border-color: #FF5722;
            background: rgba(255, 87, 34, 0.3);
            color: #FF5722;
        }
        
        .player3-controls {
            border-color: #2196F3;
        }
        
        .player3-controls .control-btn {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.2);
        }
        
        .player3-controls .shoot-btn {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.3);
            color: #2196F3;
        }
        
        .menu-btn {
            font-size: 20px;
            padding: 15px 30px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            margin: 10px;
        }
    </style>
</head>
<body>
    <div id="menu" style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #000; padding: 20px;">
        <img src="tankk.png" style="max-height: 60vh; max-width: 80vw; width: auto; display: block; margin-bottom: 30px;">
        <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
            <button onclick="selectPlayers(2)" class="menu-btn" style="background: #4CAF50;">2 PELAAJAA</button>
            <button onclick="selectPlayers(3)" class="menu-btn" style="background: #2196F3;">3 PELAAJAA</button>
        </div>
    </div>
    
    <div id="bounceMenu" style="display: none; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #000; padding: 20px;">
        <img src="tankk.png" style="max-height: 60vh; max-width: 80vw; width: auto; display: block; margin-bottom: 30px;">
        <h2 style="font-size: 36px; margin-bottom: 30px; color: #FFD700;">AMMUKSET</h2>
        <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
            <button onclick="startGame(true)" class="menu-btn" style="background: #FF9800;">KIMPOAVAT</button>
            <button onclick="startGame(false)" class="menu-btn" style="background: #9C27B0;">EIVÃ„T KIMPOA</button>
        </div>
    </div>
    
    <div id="gameContainer" style="display: none; width: 100%; height: 100vh; flex-direction: column;">
        <div id="info">
            <div id="scores">
                <div class="player1-score">P1: <span id="p1Score">0</span></div>
                <div class="player2-score">P2: <span id="p2Score">0</span></div>
                <div class="player3-score" id="p3ScoreContainer">P3: <span id="p3Score">0</span></div>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="message"></div>
        
        <div id="controls">
            <!-- Pelaaja 1 ohjaimet -->
            <div class="control-group player1-controls">
                <div class="dpad-container">
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="w">â–²</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="a">â—„</div>
                    <button class="shoot-btn" data-key=" ">P1<br>AMMU</button>
                    <div class="control-btn" data-key="d">â–º</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="s">â–¼</div>
                    <div class="control-btn empty"></div>
                </div>
            </div>
            
            <!-- Pelaaja 2 ohjaimet -->
            <div class="control-group player2-controls">
                <div class="dpad-container">
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="ArrowUp">â–²</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="ArrowLeft">â—„</div>
                    <button class="shoot-btn" data-key="Enter">P2<br>AMMU</button>
                    <div class="control-btn" data-key="ArrowRight">â–º</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="ArrowDown">â–¼</div>
                    <div class="control-btn empty"></div>
                </div>
            </div>
            
            <!-- Pelaaja 3 ohjaimet -->
            <div class="control-group player3-controls" id="p3Controls">
                <div class="dpad-container">
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="u">â–²</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="h">â—„</div>
                    <button class="shoot-btn" data-key="7">P3<br>AMMU</button>
                    <div class="control-btn" data-key="k">â–º</div>
                    <div class="control-btn empty"></div>
                    <div class="control-btn" data-key="j">â–¼</div>
                    <div class="control-btn empty"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const p1ScoreEl = document.getElementById('p1Score');
        const p2ScoreEl = document.getElementById('p2Score');
        const p3ScoreEl = document.getElementById('p3Score');
        const p3ScoreContainer = document.getElementById('p3ScoreContainer');
        const p3Controls = document.getElementById('p3Controls');
        
        // Aseta canvas koko
        function resizeCanvas() {
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight - 200; // Tilaa ohjaimille
            
            if (maxWidth / maxHeight > 2) {
                canvas.width = maxHeight * 2;
                canvas.height = maxHeight;
            } else {
                canvas.width = maxWidth;
                canvas.height = maxWidth / 2;
            }
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Pelin tila
        let scores = { p1: 0, p2: 0, p3: 0 };
        let gameOver = false;
        let playerCount = 3;
        let gameStarted = false;
        let bounceEnabled = true;
        
        function selectPlayers(numPlayers) {
            playerCount = numPlayers;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('bounceMenu').style.display = 'flex';
        }
        
        function startGame(bounce) {
            bounceEnabled = bounce;
            document.getElementById('bounceMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            
            if (playerCount === 2) {
                p3ScoreContainer.style.display = 'none';
                p3Controls.style.display = 'none';
                player3.alive = false;
            }
            
            if (!gameStarted) {
                gameStarted = true;
                generateWalls();
                gameLoop();
            }
        }
        
        // NÃ¤ppÃ¤imien tila
        const keys = {};
        
        // Kosketuskontrollit
        function setupTouchControls() {
            const buttons = document.querySelectorAll('.control-btn, .shoot-btn');
            
            buttons.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const key = btn.getAttribute('data-key');
                    if (key) {
                        keys[key] = true;
                    }
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const key = btn.getAttribute('data-key');
                    if (key) {
                        keys[key] = false;
                    }
                });
                
                // Varmuuden vuoksi
                btn.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    const key = btn.getAttribute('data-key');
                    if (key) {
                        keys[key] = false;
                    }
                });
            });
        }
        
        setupTouchControls();
        
        // Tankin luokka
        class Tank {
            constructor(x, y, color, controls) {
                this.startX = x;
                this.startY = y;
                this.x = x;
                this.y = y;
                this.width = Math.max(20, canvas.width * 0.025);
                this.height = Math.max(20, canvas.width * 0.025);
                this.color = color;
                this.angle = 0;
                this.speed = Math.max(1.5, canvas.width * 0.002);
                this.rotationSpeed = 0.05;
                this.controls = controls;
                this.canShoot = true;
                this.shootCooldown = 0;
                this.alive = true;
            }
            
            update() {
                if (!this.alive) return;
                
                if (keys[this.controls.left]) {
                    this.angle -= this.rotationSpeed;
                }
                if (keys[this.controls.right]) {
                    this.angle += this.rotationSpeed;
                }
                
                let newX = this.x;
                let newY = this.y;
                
                if (keys[this.controls.up]) {
                    newX += Math.cos(this.angle) * this.speed;
                    newY += Math.sin(this.angle) * this.speed;
                }
                if (keys[this.controls.down]) {
                    newX -= Math.cos(this.angle) * this.speed;
                    newY -= Math.sin(this.angle) * this.speed;
                }
                
                if (!this.checkWallCollision(newX, newY)) {
                    this.x = newX;
                    this.y = newY;
                }
                
                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(canvas.height - this.height/2, this.y));
                
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                } else {
                    this.canShoot = true;
                }
                
                if (keys[this.controls.shoot] && this.canShoot) {
                    this.shoot();
                    this.canShoot = false;
                    this.shootCooldown = 30;
                }
            }
            
            checkWallCollision(x, y) {
                for (let wall of walls) {
                    if (x + this.width/2 > wall.x && 
                        x - this.width/2 < wall.x + wall.width &&
                        y + this.height/2 > wall.y && 
                        y - this.height/2 < wall.y + wall.height) {
                        return true;
                    }
                }
                return false;
            }
            
            shoot() {
                const bulletSpeed = Math.max(3, canvas.width * 0.004);
                const bullet = new Bullet(
                    this.x + Math.cos(this.angle) * this.width/2,
                    this.y + Math.sin(this.angle) * this.height/2,
                    Math.cos(this.angle) * bulletSpeed,
                    Math.sin(this.angle) * bulletSpeed,
                    this.color
                );
                bullets.push(bullet);
                playShootSound();
            }
            
            draw() {
                if (!this.alive) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                const r = parseInt(this.color.slice(1,3), 16);
                const g = parseInt(this.color.slice(3,5), 16);
                const b = parseInt(this.color.slice(5,7), 16);
                const darkerColor = `rgb(${Math.max(0, r-40)}, ${Math.max(0, g-40)}, ${Math.max(0, b-40)})`;
                
                ctx.fillStyle = darkerColor;
                ctx.fillRect(-this.width/2 - 3, -this.height/2 + 3, 3, this.height - 6);
                ctx.fillRect(this.width/2, -this.height/2 + 3, 3, this.height - 6);
                
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width/4, -this.height/3, this.width/2, this.height * 0.66);
                
                ctx.fillStyle = darkerColor;
                ctx.fillRect(0, -3, this.width/2 + 8, 6);
                
                ctx.beginPath();
                ctx.arc(0, 0, this.width/5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.strokeRect(-this.width/4, -this.height/3, this.width/2, this.height * 0.66);
                
                ctx.restore();
            }
            
            hit() {
                this.alive = false;
            }
            
            reset(x, y) {
                this.x = x || this.startX;
                this.y = y || this.startY;
                this.angle = 0;
                this.alive = true;
                this.canShoot = true;
                this.shootCooldown = 0;
            }
        }
        
        class Bullet {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = Math.max(3, canvas.width * 0.003);
                this.color = color;
                this.bounces = 3;
                this.active = true;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (bounceEnabled) {
                    if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
                        this.vx *= -1;
                        this.bounces--;
                        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                    }
                    if (this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) {
                        this.vy *= -1;
                        this.bounces--;
                        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                    }
                    
                    for (let wall of walls) {
                        if (this.checkWallCollision(wall)) {
                            this.bounceOffWall(wall);
                            this.bounces--;
                        }
                    }
                    
                    if (this.bounces <= 0) {
                        this.active = false;
                    }
                } else {
                    if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width ||
                        this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) {
                        this.active = false;
                    }
                    
                    for (let wall of walls) {
                        if (this.checkWallCollision(wall)) {
                            this.active = false;
                            break;
                        }
                    }
                }
            }
            
            checkWallCollision(wall) {
                let closestX = Math.max(wall.x, Math.min(this.x, wall.x + wall.width));
                let closestY = Math.max(wall.y, Math.min(this.y, wall.y + wall.height));
                
                let distX = this.x - closestX;
                let distY = this.y - closestY;
                
                return (distX * distX + distY * distY) < (this.radius * this.radius);
            }
            
            bounceOffWall(wall) {
                let closestX = Math.max(wall.x, Math.min(this.x, wall.x + wall.width));
                let closestY = Math.max(wall.y, Math.min(this.y, wall.y + wall.height));
                
                let distX = this.x - closestX;
                let distY = this.y - closestY;
                
                if (Math.abs(distX) > Math.abs(distY)) {
                    this.vx *= -1;
                    this.x += this.vx * 2;
                } else {
                    this.vy *= -1;
                    this.y += this.vy * 2;
                }
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }
        
        class Wall {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = Math.random() < 0.5 ? 'building' : 'warehouse';
                this.windows = [];
                
                if (this.type === 'building') {
                    const rows = Math.floor(this.height / 20);
                    const cols = Math.floor(this.width / 20);
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            if (Math.random() > 0.3) {
                                this.windows.push({
                                    x: this.x + c * 20 + 5,
                                    y: this.y + r * 20 + 5,
                                    lit: Math.random() > 0.5
                                });
                            }
                        }
                    }
                }
            }
            
            draw() {
                if (this.type === 'building') {
                    const buildingColors = ['#4A4A4A', '#5A5A5A', '#6A6A6A', '#7A5A4A'];
                    ctx.fillStyle = buildingColors[Math.floor(this.x + this.y) % buildingColors.length];
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    this.windows.forEach(window => {
                        ctx.fillStyle = window.lit ? '#FFEB3B' : '#2C2C2C';
                        ctx.fillRect(window.x, window.y, 8, 8);
                    });
                    
                    ctx.strokeStyle = '#1A1A1A';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    
                } else {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(this.x, this.y, this.width, this.height * 0.2);
                    
                    ctx.fillStyle = '#2C2C2C';
                    ctx.fillRect(this.x + this.width * 0.4, this.y + this.height * 0.5, this.width * 0.2, this.height * 0.5);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                }
            }
        }
        
        const player1 = new Tank(canvas.width * 0.08, canvas.height * 0.25, '#00FF00', {
            up: 'w',
            down: 's',
            left: 'a',
            right: 'd',
            shoot: ' '
        });
        
        const player2 = new Tank(canvas.width * 0.92, canvas.height * 0.5, '#FF5722', {
            up: 'ArrowUp',
            down: 'ArrowDown',
            left: 'ArrowLeft',
            right: 'ArrowRight',
            shoot: 'Enter'
        });
        
        const player3 = new Tank(canvas.width * 0.5, canvas.height * 0.83, '#2196F3', {
            up: 'u',
            down: 'j',
            left: 'h',
            right: 'k',
            shoot: '7'
        });
        
        player2.angle = Math.PI;
        
        const bullets = [];
        let walls = [];
        const explosions = [];
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playShootSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 200;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playExplosionSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 100;
            oscillator.type = 'sawtooth';
            filter.type = 'lowpass';
            filter.frequency.value = 500;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }
        
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = Math.max(30, canvas.width * 0.033);
                this.life = 30;
                this.maxLife = 30;
                this.particles = [];
                
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = 2 + Math.random() * 3;
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1
                    });
                }
            }
            
            update() {
                this.life--;
                this.radius = this.maxRadius * (1 - this.life / this.maxLife);
                
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                });
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 140, 0, ${alpha * 0.7})`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
                
                this.particles.forEach(p => {
                    if (p.life > 0) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 100, 0, ${p.life})`;
                        ctx.fill();
                    }
                });
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        function generateWalls() {
            walls = [];
            
            const player1SafeZone = { 
                x: canvas.width * 0.04, 
                y: canvas.height * 0.17, 
                width: canvas.width * 0.08, 
                height: canvas.height * 0.17 
            };
            const player2SafeZone = { 
                x: canvas.width * 0.88, 
                y: canvas.height * 0.42, 
                width: canvas.width * 0.08, 
                height: canvas.height * 0.17 
            };
            const player3SafeZone = { 
                x: canvas.width * 0.46, 
                y: canvas.height * 0.75, 
                width: canvas.width * 0.08, 
                height: canvas.height * 0.17 
            };
            
            const wallCount = Math.floor(Math.random() * 8) + 8;
            
            for (let i = 0; i < wallCount; i++) {
                let validPosition = false;
                let x, y, width, height;
                let attempts = 0;
                
                while (!validPosition && attempts < 50) {
                    width = Math.random() < 0.3 ? 
                        Math.floor(Math.random() * canvas.width * 0.08) + canvas.width * 0.05 :
                        Math.floor(Math.random() * canvas.width * 0.05) + canvas.width * 0.05;
                    
                    height = Math.random() < 0.3 ? 
                        Math.floor(Math.random() * canvas.height * 0.17) + canvas.height * 0.1 :
                        Math.floor(Math.random() * canvas.height * 0.1) + canvas.height * 0.067;
                    
                    x = Math.floor(Math.random() * (canvas.width - width - canvas.width * 0.08)) + canvas.width * 0.04;
                    y = Math.floor(Math.random() * (canvas.height - height - canvas.height * 0.17)) + canvas.height * 0.08;
                    
                    const notInP1Zone = !(x < player1SafeZone.x + player1SafeZone.width &&
                                         x + width > player1SafeZone.x &&
                                         y < player1SafeZone.y + player1SafeZone.height &&
                                         y + height > player1SafeZone.y);
                    
                    const notInP2Zone = !(x < player2SafeZone.x + player2SafeZone.width &&
                                         x + width > player2SafeZone.x &&
                                         y < player2SafeZone.y + player2SafeZone.height &&
                                         y + height > player2SafeZone.y);
                    
                    const notInP3Zone = !(x < player3SafeZone.x + player3SafeZone.width &&
                                         x + width > player3SafeZone.x &&
                                         y < player3SafeZone.y + player3SafeZone.height &&
                                         y + height > player3SafeZone.y);
                    
                    let tooClose = false;
                    for (let wall of walls) {
                        if (x < wall.x + wall.width + 30 &&
                            x + width > wall.x - 30 &&
                            y < wall.y + wall.height + 30 &&
                            y + height > wall.y - 30) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (notInP1Zone && notInP2Zone && notInP3Zone && !tooClose) {
                        validPosition = true;
                    }
                    
                    attempts++;
                }
                
                if (validPosition) {
                    walls.push(new Wall(x, y, width, height));
                }
            }
        }
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' || e.key === 'Enter') {
                e.preventDefault();
            }
            
            if (e.key === 'r' || e.key === 'R') {
                resetGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                if (!bullet.active) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                if (player1.alive && checkBulletTankCollision(bullet, player1) && bullet.color !== player1.color) {
                    explosions.push(new Explosion(player1.x, player1.y));
                    playExplosionSound();
                    player1.hit();
                    bullets.splice(i, 1);
                    checkGameOver();
                    continue;
                }
                
                if (player2.alive && checkBulletTankCollision(bullet, player2) && bullet.color !== player2.color) {
                    explosions.push(new Explosion(player2.x, player2.y));
                    playExplosionSound();
                    player2.hit();
                    bullets.splice(i, 1);
                    checkGameOver();
                    continue;
                }
                
                if (player3.alive && checkBulletTankCollision(bullet, player3) && bullet.color !== player3.color) {
                    explosions.push(new Explosion(player3.x, player3.y));
                    playExplosionSound();
                    player3.hit();
                    bullets.splice(i, 1);
                    checkGameOver();
                    continue;
                }
            }
        }
        
        function checkBulletTankCollision(bullet, tank) {
            const dx = bullet.x - tank.x;
            const dy = bullet.y - tank.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            return distance < bullet.radius + tank.width/2;
        }
        
        function checkGameOver() {
            let alivePlayers = [];
            
            if (player1.alive) alivePlayers.push(1);
            if (player2.alive) alivePlayers.push(2);
            if (playerCount === 3 && player3.alive) alivePlayers.push(3);
            
            if (alivePlayers.length === 1) {
                endRound(alivePlayers[0]);
            }
        }
        
        function endRound(winner) {
            gameOver = true;
            
            if (winner === 1) {
                scores.p1++;
                messageEl.textContent = 'ðŸŽ‰ Pelaaja 1 voitti! Kosketa ruutua aloittaaksesi uuden kierroksen.';
            } else if (winner === 2) {
                scores.p2++;
                messageEl.textContent = 'ðŸŽ‰ Pelaaja 2 voitti! Kosketa ruutua aloittaaksesi uuden kierroksen.';
            } else {
                scores.p3++;
                messageEl.textContent = 'ðŸŽ‰ Pelaaja 3 voitti! Kosketa ruutua aloittaaksesi uuden kierroksen.';
            }
            
            p1ScoreEl.textContent = scores.p1;
            p2ScoreEl.textContent = scores.p2;
            p3ScoreEl.textContent = scores.p3;
            
            // Mahdollista aloittaa uusi kierros kosketuksella
            canvas.addEventListener('touchstart', resetGame, { once: true });
        }
        
        function resetGame() {
            gameOver = false;
            player1.reset();
            player2.reset();
            
            if (playerCount === 3) {
                player3.reset();
            }
            
            player2.angle = Math.PI;
            bullets.length = 0;
            messageEl.textContent = '';
            generateWalls();
        }
        
        function drawCityBackground() {
            ctx.fillStyle = '#1a3a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4a4a4a';
            
            for (let y = canvas.height * 0.25; y < canvas.height; y += canvas.height * 0.37) {
                ctx.fillRect(0, y - canvas.height * 0.025, canvas.width, canvas.height * 0.05);
            }
            
            for (let x = canvas.width * 0.17; x < canvas.width; x += canvas.width * 0.23) {
                ctx.fillRect(x - canvas.width * 0.0125, 0, canvas.width * 0.025, canvas.height);
            }
            
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            
            for (let y = canvas.height * 0.25; y < canvas.height; y += canvas.height * 0.37) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            for (let x = canvas.width * 0.17; x < canvas.width; x += canvas.width * 0.23) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        function gameLoop() {
            drawCityBackground();
            
            walls.forEach(wall => wall.draw());
            
            if (!gameOver) {
                player1.update();
                player2.update();
                if (playerCount === 3) {
                    player3.update();
                }
                
                bullets.forEach(bullet => bullet.update());
                
                checkCollisions();
            }
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].update();
                if (explosions[i].isDead()) {
                    explosions.splice(i, 1);
                }
            }
            
            bullets.forEach(bullet => bullet.draw());
            
            explosions.forEach(explosion => explosion.draw());
            
            player1.draw();
            player2.draw();
            if (playerCount === 3) {
                player3.draw();
            }
            
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
