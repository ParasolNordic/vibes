<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Woodblock Galore</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background: 
                radial-gradient(ellipse at 20% 30%, rgba(45, 90, 61, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 70%, rgba(26, 61, 46, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(35, 74, 53, 0.2) 0%, transparent 60%),
                linear-gradient(135deg, #2d5a3d 0%, #1f4a35 15%, #1a3d2e 30%, #234a35 45%, #1f4430 60%, #2a5540 75%, #1e4533 90%, #2d5a3d 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            padding-top: 10px;
        }
        
        .game-area {
            position: relative;
            margin-bottom: 10px;
        }
        
        .game-board {
            background: #1a1a2e;
            padding: 8px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            pointer-events: none;
        }
        
        #gameCanvas {
            display: block;
            border: 2px solid #16213e;
            border-radius: 5px;
            pointer-events: auto;
        }
        
        .next-piece-box {
            position: absolute;
            top: 8px;
            right: -44px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            width: 39px;
        }
        
        .next-piece-box label {
            display: none;
        }
        
        .next-piece-box button {
            width: 100%;
            padding: 3px 0;
            margin-top: 2px;
            font-size: 10px;
            border-radius: 3px;
            line-height: 1;
        }
        
        #nextCanvas {
            background: #f0f0f0;
            border-radius: 2px;
            display: block;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            width: 340px;
        }
        
        .title {
            text-align: center;
            color: #1a4030;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 6px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
            text-align: center;
        }
        
        .stat label {
            display: block;
            font-size: 9px;
            color: #000000;
            font-weight: bold;
        }
        
        .stat value {
            display: block;
            font-size: 16px;
            color: #000000;
            font-weight: bold;
        }
        
        button {
            width: 100%;
            padding: 10px;
            font-size: 15px;
            font-weight: bold;
            color: #ffffff;
            background: linear-gradient(135deg, #9d7f52 0%, #7a5f3d 20%, #5e4a2f 40%, #6b5638 60%, #8b6f47 80%, #9d7f52 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .center-button {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            padding: 10px;
            font-size: 15px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            white-space: nowrap;
            pointer-events: auto;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .game-over-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 1000;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .game-over-screen h1 {
            color: #764ba2;
            margin-bottom: 20px;
        }
        
        .game-over-screen .final-score {
            font-size: 48px;
            color: #667eea;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .analysis-section {
            margin-top: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 10px;
            text-align: left;
        }
        
        .analysis-section h2 {
            color: #1a4030;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .analysis-text {
            color: #333;
            line-height: 1.6;
            font-size: 14px;
        }
        
        .loading {
            color: #667eea;
            font-style: italic;
        }
        
        .copy-data-button {
            margin-top: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .hall-of-fame {
            position: absolute;
            top: calc(25% + 25px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 340px;
            z-index: 9998;
        }
        
        .hall-of-fame h3 {
            text-align: center;
            color: #1a4030;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .hall-of-fame-list {
            font-size: 11px;
            color: #333;
        }
        
        .hall-of-fame-entry {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .hall-of-fame-entry:last-child {
            border-bottom: none;
        }
        
        .hall-of-fame-rank {
            font-weight: bold;
            color: #667eea;
            width: 25px;
        }
        
        .hall-of-fame-score {
            flex: 1;
            text-align: center;
            font-weight: bold;
        }
        
        .hall-of-fame-date {
            color: #666;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div class="game-area">
        <div class="game-board">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
            <button id="startBtn" class="center-button">Aloita peli</button>
        </div>
        <div class="next-piece-box">
            <label>Seuraava</label>
            <canvas id="nextCanvas" width="35" height="35"></canvas>
            <button id="pauseBtn" style="display:none;">II</button>
        </div>
    </div>
    
    <div class="info-panel">
        <div class="title">WOODBLOCK GALORE</div>
        
        <div class="stats">
            <div class="stat">
                <label>Pisteet</label>
                <value id="score">0</value>
            </div>
            <div class="stat">
                <label>Rivit</label>
                <value id="lines">0</value>
            </div>
            <div class="stat">
                <label>Nopeus</label>
                <value id="speed">100%</value>
            </div>
            <div class="stat">
                <label>Taso</label>
                <value id="level">1</value>
            </div>
        </div>
    </div>

    <div class="hall-of-fame" id="hallOfFame" style="display:none;">
        <h3>üèÜ WOODBLOCK HALL OF GALORE üèÜ</h3>
        <div class="hall-of-fame-list" id="hallOfFameList">
        </div>
    </div>

    <script>
        console.log('Script starting...');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const hallOfFame = document.getElementById('hallOfFame');
        const hallOfFameList = document.getElementById('hallOfFameList');
        
        console.log('Elements found:', {canvas, nextCanvas, startBtn, pauseBtn});
        
        // Hall of Fame API (k√§ytt√§√§ Cloudflare Workers KV -tallennusta)
        const HALL_OF_FAME_API = 'https://woodblock-hall-of-fame.arkisto-kaksi.workers.dev';
        
        // Hall of Fame -toiminnot
        async function loadHallOfFame() {
            try {
                const response = await fetch(`${HALL_OF_FAME_API}/scores`);
                
                if (!response.ok) {
                    console.log('Hall of Fame ei viel√§ olemassa');
                    return [];
                }
                
                const data = await response.json();
                return data.scores || [];
            } catch (e) {
                console.error('Virhe Hall of Famen lataamisessa:', e);
                return [];
            }
        }
        
        async function saveHallOfFame(entries) {
            try {
                const response = await fetch(`${HALL_OF_FAME_API}/scores`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ scores: entries })
                });
                
                if (!response.ok) {
                    throw new Error('Tallennus ep√§onnistui');
                }
                
                console.log('Hall of Fame tallennettu onnistuneesti');
            } catch (e) {
                console.error('Ei voitu tallentaa Hall of Famea:', e);
            }
        }
        
        async function updateHallOfFame(newScore) {
            const entries = await loadHallOfFame();
            const date = new Date();
            const dateStr = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()}`;
            
            entries.push({
                score: newScore,
                date: dateStr
            });
            
            // J√§rjest√§ pisteiden mukaan laskevasti ja ota top 10
            entries.sort((a, b) => b.score - a.score);
            const top10 = entries.slice(0, 10);
            
            await saveHallOfFame(top10);
            // P√§ivit√§ Hall of Fame sis√§lt√∂ taustalla, mutta √ÑL√Ñ n√§yt√§ sit√§
            await displayHallOfFame(false);
            
            return top10;
        }
        
        async function displayHallOfFame(showOnlyAtStart = false) {
            const entries = await loadHallOfFame();
            
            if (entries.length === 0) {
                hallOfFame.style.display = 'none';
                return;
            }
            
            // N√§yt√§ vain jos ollaan aloitusn√§kym√§ss√§
            if (showOnlyAtStart) {
                hallOfFame.style.display = 'block';
            }
            
            hallOfFameList.innerHTML = entries.map((entry, index) => `
                <div class="hall-of-fame-entry">
                    <span class="hall-of-fame-rank">${index + 1}.</span>
                    <span class="hall-of-fame-score">${entry.score} pistett√§</span>
                    <span class="hall-of-fame-date">${entry.date}</span>
                </div>
            `).join('');
        }
        
        // N√§yt√§ Hall of Fame sivun latautuessa
        displayHallOfFame(true);
        
        const COLS = 10;
        const ROWS = 20;
        const BLOCK = 30;
        
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];
        
        // Tetris-tyylinen piece notation
        const PIECE_NAMES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
        
        const COLOR = '#d4a574';
        
        let board = [];
        let score = 0;
        let lines = 0;
        let level = 1;
        let speed = 1000;
        let dropTime = 0;
        let lastTime = 0;
        let current, next;
        let x, y;
        let gameOver = false;
        let paused = false;
        let lockDelay = false;
        let lockTimer = 0;
        const LOCK_DELAY_TIME = 500;
        let baseLineScore = 10; // Alkupisteet yhdest√§ rivist√§
        let totalLinesCleared = 0; // Kokonaisrivim√§√§r√§ pistelaskentaa varten
        
        // === PELITIETOJEN TALLENNUSJ√ÑRJESTELM√Ñ ===
        let gameSession = {
            startTime: null,
            endTime: null,
            moves: [],           // Kaikki peliliikkeet
            placements: [],      // Kaikki pudotetut palikat
            lineClears: [],      // Kaikki rivien tyhjennykset
            stats: {
                totalMoves: 0,
                leftMoves: 0,
                rightMoves: 0,
                rotations: 0,
                hardDrops: 0,
                softDrops: 0
            }
        };
        
        function initGameSession() {
            gameSession = {
                startTime: Date.now(),
                endTime: null,
                moves: [],
                placements: [],
                lineClears: [],
                stats: {
                    totalMoves: 0,
                    leftMoves: 0,
                    rightMoves: 0,
                    rotations: 0,
                    hardDrops: 0,
                    softDrops: 0
                }
            };
        }
        
        function recordMove(moveType, details = {}) {
            const timestamp = Date.now() - gameSession.startTime;
            gameSession.moves.push({
                timestamp,
                type: moveType,
                piece: current ? PIECE_NAMES[SHAPES.indexOf(current.shape)] : null,
                position: {x, y},
                rotation: current ? current.rotation || 0 : 0,
                speed: speed,
                level: level,
                ...details
            });
            gameSession.stats.totalMoves++;
            
            // P√§ivit√§ tyyppikohtaiset tilastot
            if (moveType === 'left') gameSession.stats.leftMoves++;
            else if (moveType === 'right') gameSession.stats.rightMoves++;
            else if (moveType === 'rotate') gameSession.stats.rotations++;
            else if (moveType === 'hardDrop') gameSession.stats.hardDrops++;
            else if (moveType === 'softDrop') gameSession.stats.softDrops++;
        }
        
        function recordPlacement(clearedLines = []) {
            const timestamp = Date.now() - gameSession.startTime;
            const pieceName = PIECE_NAMES[SHAPES.indexOf(current.shape)];
            
            // Tallenna palikan sijoitus
            const placement = {
                timestamp,
                piece: pieceName,
                position: {x, y},
                rotation: current.rotation || 0,
                speed: speed,
                level: level,
                linesCleared: clearedLines.length
            };
            
            gameSession.placements.push(placement);
            
            // Jos rivej√§ tyhjennettiin, tallenna ne erikseen
            if (clearedLines.length > 0) {
                gameSession.lineClears.push({
                    timestamp,
                    rows: clearedLines,
                    count: clearedLines.length,
                    score: score,
                    level: level,
                    piece: pieceName
                });
            }
        }
        
        function getGameDataString() {
            gameSession.endTime = Date.now();
            
            // Palauta koko JSON kaikkine tietoineen
            return JSON.stringify(gameSession, null, 2);
        }
        
        function getSummaryString() {
            // Laske peliaika
            const gameTimeMs = gameSession.endTime - gameSession.startTime;
            const gameTimeMin = (gameTimeMs / 60000).toFixed(2);
            
            // Laske keskim√§√§r√§inen aika per siirto
            const avgMoveTime = gameSession.moves.length > 0 ? 
                (gameTimeMs / gameSession.moves.length).toFixed(0) : 0;
            
            // Analysoi strategiaa
            const moveFrequency = {
                left: gameSession.stats.leftMoves,
                right: gameSession.stats.rightMoves,
                rotate: gameSession.stats.rotations,
                hardDrop: gameSession.stats.hardDrops
            };
            
            // Analysoi rivien tyhjennystyyli√§
            const lineClearTypes = {};
            gameSession.lineClears.forEach(lc => {
                const type = lc.count === 1 ? 'single' : 
                            lc.count === 2 ? 'double' : 
                            lc.count === 3 ? 'triple' : 'tetris';
                lineClearTypes[type] = (lineClearTypes[type] || 0) + 1;
            });
            
            const dataString = `Pisteet ${score}, rivit ${lines}, taso ${level}, aika ${gameTimeMin}min. Siirrot: vasen ${moveFrequency.left}, oikea ${moveFrequency.right}, k√§√§nn√∂s ${moveFrequency.rotate}, pudotus ${moveFrequency.hardDrop}. Rivityhjennykset: ${Object.entries(lineClearTypes).map(([t,c]) => `${t} ${c}`).join(', ')}. Keskiaika per siirto ${avgMoveTime}ms.`;
            
            return dataString;
        }
        
        async function sendGameDataToLLM() {
            gameSession.endTime = Date.now();
            const fullGameData = getGameDataString();
            const prompt = `T√§ss√§ on t√§ydellinen Tetris-pelisessio JSON-muodossa:

${fullGameData}

Analysoi pelityylini t√§m√§n datan perusteella: vahvuuteni, heikkouteni ja anna 4-6 konkreettista parannusvinkki√§. Vastaa tiiviisti maksimissaan 500 merkki√§ sinutellen. Ei t√§htimerkkej√§ tai luettelomerkkej√§. Joka vinkki omaan virkkeeseen. Varmista ett√§ viimeinen virke on kokonainen.`;

            try {
                console.log('L√§hetet√§√§n t√§ydellinen pelisessio LLM:lle...');
                
                const response = await fetch('https://ai-proxy.arkisto-kaksi.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        messages: [
                            {
                                role: 'system',
                                content: 'Olet Tetris-analysoija joka saa yksityiskohtaisen JSON-datan pelaajan kaikista liikkeist√§ ja sijoituksista. Anna syv√§llinen mutta tiivis analyysi maksimissaan 500 merkki√§ sinutellen. Kirjoita jatkuvaa teksti√§ ilman t√§htimerkkej√§ tai luettelomerkkej√§. Jokainen vinkki omaan virkkeeseen. Varmista ett√§ viimeinen lause on kokonainen eik√§ katkea kesken.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ]
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Worker error ${response.status}: ${errorData.error || response.statusText}`);
                }
                
                const data = await response.json();
                console.log('LLM response data:', data);
                
                let analysis = data.result?.response || data.response || 'Analyysi ei saatavilla';
                
                // Varmista ett√§ ei katkea kesken lauseen
                if (analysis.length > 600) {
                    // Etsi viimeinen piste ennen 600 merkki√§
                    const cutPoint = analysis.lastIndexOf('.', 600);
                    if (cutPoint > 400) {
                        analysis = analysis.substring(0, cutPoint + 1);
                    } else {
                        analysis = analysis.substring(0, 597) + '...';
                    }
                }
                
                console.log('Analyysi vastaanotettu:', analysis);
                return analysis;
                
            } catch (error) {
                console.error('Virhe LLM-analyysiss√§:', error);
                
                const efficiency = (lines / gameSession.placements.length * 100).toFixed(1);
                const rotPercent = (gameSession.stats.rotations / gameSession.stats.totalMoves * 100).toFixed(0);
                
                return `Sait ${score} pistett√§ ja tyhjensit ${lines} rivi√§. Tehokkuutesi oli ${efficiency} prosenttia. K√§ytit k√§√§nt√∂j√§ ${rotPercent} prosenttia liikkeist√§si. Paranna seuraavaa: Suunnittele palikoiden sijoitus etuk√§teen. T√§ht√§√§ 4 rivin Tetris-comboihin. J√§t√§ tyhj√§ kolumni oikealle I-palikalle. K√§yt√§ hold-toimintoa strategisesti. Harjoittele nopeampaa p√§√§t√∂ksentekoa.`;
            }
        }
        
        // === ALKUPER√ÑINEN PELILOGIIKKA ===
        
        function init() {
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            speed = 1000;
            gameOver = false;
            baseLineScore = 10;
            totalLinesCleared = 0;
            updateDisplay();
            initGameSession();
        }
        
        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
            document.getElementById('speed').textContent = Math.round(1000/speed*100) + '%';
        }
        
        function newPiece() {
            const i = Math.floor(Math.random() * SHAPES.length);
            return {
                shape: SHAPES[i],
                color: COLOR,
                rotation: 0
            };
        }
        
        function spawn() {
            current = next || newPiece();
            next = newPiece();
            x = Math.floor((COLS - current.shape[0].length) / 2);
            y = 0;
            lockDelay = false;
            lockTimer = 0;
            
            console.log('Spawning piece at', x, y, 'Next piece ready:', next);
            drawNext();
            
            if (collide(0, 0)) {
                endGame();
            }
        }
        
        function collide(dx, dy, shape = current.shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const nx = x + col + dx;
                        const ny = y + row + dy;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
                }
            }
            return false;
        }
        
        function merge() {
            for (let row = 0; row < current.shape.length; row++) {
                for (let col = 0; col < current.shape[row].length; col++) {
                    if (current.shape[row][col]) {
                        if (y + row >= 0) {
                            board[y + row][x + col] = current.color;
                        }
                    }
                }
            }
        }
        
        function rotate() {
            const rows = current.shape.length;
            const cols = current.shape[0].length;
            const rotated = Array.from({length: cols}, () => Array(rows).fill(0));
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    rotated[col][rows - 1 - row] = current.shape[row][col];
                }
            }
            
            if (!collide(0, 0, rotated)) {
                current.shape = rotated;
                current.rotation = ((current.rotation || 0) + 1) % 4;
                recordMove('rotate');
            }
        }
        
        function moveLeft() {
            if (!collide(-1, 0)) {
                x--;
                lockDelay = false;
                lockTimer = 0;
                recordMove('left');
            }
        }
        
        function moveRight() {
            if (!collide(1, 0)) {
                x++;
                lockDelay = false;
                lockTimer = 0;
                recordMove('right');
            }
        }
        
        function clearLines() {
            let cleared = 0;
            let clearedRows = [];
            
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    board.splice(row, 1);
                    board.unshift(Array(COLS).fill(0));
                    cleared++;
                    clearedRows.push(row);
                    row++;
                }
            }
            
            if (cleared > 0) {
                lines += cleared;
                
                // Uusi pistelaskenta: progressiivinen
                let pointsEarned = 0;
                for (let i = 0; i < cleared; i++) {
                    pointsEarned += Math.floor(baseLineScore);
                    totalLinesCleared++;
                    // Nopeus kasvaa 10% joka rivin j√§lkeen
                    speed = Math.max(100, speed * 0.9);
                    // Pistem√§√§r√§ kasvaa 10% joka rivin j√§lkeen
                    baseLineScore = baseLineScore * 1.1;
                }
                
                // Tetris-bonus: 4 rivi√§ kerralla = +50 pistett√§ + √§√§ni
                if (cleared === 4) {
                    pointsEarned += 50;
                    playTetrisSound();
                }
                
                score += pointsEarned;
                
                // Taso nousee edelleen 10 rivin v√§lein
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                }
                
                updateDisplay();
            }
            
            return clearedRows;
        }
        
        // Tetris-√§√§niefekti
        function playTetrisSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Melodinen "kilahdus" 
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            } catch (error) {
                console.log('Audio not supported:', error);
            }
        }
        
        function drop() {
            if (!collide(0, 1)) {
                y++;
                lockDelay = false;
                lockTimer = 0;
                recordMove('softDrop');
            } else {
                if (!lockDelay) {
                    lockDelay = true;
                    lockTimer = 0;
                } else if (lockTimer >= LOCK_DELAY_TIME) {
                    merge();
                    const clearedRows = clearLines();
                    recordPlacement(clearedRows);
                    spawn();
                }
            }
        }
        
        function hardDrop() {
            while (!collide(0, 1)) y++;
            recordMove('hardDrop');
            merge();
            const clearedRows = clearLines();
            recordPlacement(clearedRows);
            spawn();
        }
        
        function draw() {
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col]) {
                        ctx.fillStyle = board[row][col];
                        ctx.fillRect(col * BLOCK, row * BLOCK, BLOCK, BLOCK);
                        ctx.strokeStyle = '#1a1a2e';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(col * BLOCK, row * BLOCK, BLOCK, BLOCK);
                    }
                }
            }
            
            if (current) {
                for (let row = 0; row < current.shape.length; row++) {
                    for (let col = 0; col < current.shape[row].length; col++) {
                        if (current.shape[row][col]) {
                            ctx.fillStyle = current.color;
                            ctx.fillRect((x + col) * BLOCK, (y + row) * BLOCK, BLOCK, BLOCK);
                            ctx.strokeStyle = '#1a1a2e';
                            ctx.lineWidth = 2;
                            ctx.strokeRect((x + col) * BLOCK, (y + row) * BLOCK, BLOCK, BLOCK);
                        }
                    }
                }
            }
        }
        
        function drawNext() {
            console.log('Drawing next piece:', next);
            nextCtx.fillStyle = '#f0f0f0';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (next) {
                const maxWidth = nextCanvas.width - 2;
                const maxHeight = nextCanvas.height - 2;
                const blockWidth = Math.floor(maxWidth / next.shape[0].length);
                const blockHeight = Math.floor(maxHeight / next.shape.length);
                const b = Math.min(blockWidth, blockHeight);
                
                const ox = Math.floor((nextCanvas.width - next.shape[0].length * b) / 2);
                const oy = Math.floor((nextCanvas.height - next.shape.length * b) / 2);
                
                console.log('Next piece details:', {blockSize: b, offsetX: ox, offsetY: oy, shape: next.shape});
                
                for (let row = 0; row < next.shape.length; row++) {
                    for (let col = 0; col < next.shape[row].length; col++) {
                        if (next.shape[row][col]) {
                            nextCtx.fillStyle = next.color;
                            nextCtx.fillRect(ox + col * b, oy + row * b, b, b);
                            nextCtx.strokeStyle = '#1a1a2e';
                            nextCtx.lineWidth = 0.5;
                            nextCtx.strokeRect(ox + col * b, oy + row * b, b, b);
                        }
                    }
                }
            } else {
                console.log('No next piece to draw');
            }
        }
        
        function update(time) {
            if (gameOver || paused) return;
            
            const dt = time - lastTime;
            lastTime = time;
            dropTime += dt;
            
            if (lockDelay) lockTimer += dt;
            
            if (dropTime > speed) {
                drop();
                dropTime = 0;
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        function startGame() {
            console.log('Game starting!');
            
            const gameOverDiv = document.querySelector('.game-over-screen');
            if (gameOverDiv) gameOverDiv.remove();
            
            init();
            spawn();
            paused = false;
            startBtn.style.display = 'none';
            pauseBtn.style.display = 'block';
            pauseBtn.textContent = 'II';
            
            // Piilota Hall of Fame pysyv√§sti pelin alkaessa
            hallOfFame.style.display = 'none';
            
            requestAnimationFrame(update);
        }
        
        async function endGame() {
            gameOver = true;
            pauseBtn.style.display = 'none';
            pauseBtn.textContent = 'II';
            startBtn.style.display = 'block';
            startBtn.textContent = 'Pelaa uudelleen';
            
            // P√§ivit√§ Hall of Fame taustalla (mutta √§l√§ n√§yt√§ sit√§)
            await updateHallOfFame(score);
            
            const div = document.createElement('div');
            div.className = 'game-over-screen';
            div.innerHTML = `
                <h1>PELI P√Ñ√ÑTTYI</h1>
                <div class="final-score">${score}</div>
                <div>Rivit: ${lines}</div>
                <div>Taso: ${level}</div>
                <div class="analysis-section">
                    <h2>Pelityylisi analyysi</h2>
                    <div class="analysis-text loading">Analysoidaan peli√§si...</div>
                </div>
                <button class="copy-data-button" id="copyDataBtn">üìã Kopioi pelidata leikep√∂yd√§lle</button>
            `;
            document.body.appendChild(div);
            
            // Hae analyysi LLM:lt√§
            const analysis = await sendGameDataToLLM();
            const analysisDiv = div.querySelector('.analysis-text');
            analysisDiv.textContent = analysis;
            analysisDiv.classList.remove('loading');
            
            // Lis√§√§ kopiointitoiminto napille
            const copyDataBtn = document.getElementById('copyDataBtn');
            copyDataBtn.onclick = function() {
                const gameData = getGameDataString();
                navigator.clipboard.writeText(gameData).then(() => {
                    const originalText = copyDataBtn.textContent;
                    copyDataBtn.textContent = '‚úì Kopioitu!';
                    setTimeout(() => {
                        copyDataBtn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('Kopiointi ep√§onnistui:', err);
                    copyDataBtn.textContent = '‚ùå Virhe';
                    setTimeout(() => {
                        copyDataBtn.textContent = 'üìã Kopioi pelidata leikep√∂yd√§lle';
                    }, 2000);
                });
            };
        }
        
        // Controls
        let touchX, touchY, touchTime, swiping, lastMove;
        
        canvas.addEventListener('touchstart', (e) => {
            if (gameOver || startBtn.style.display !== 'none') {
                return;
            }
            e.preventDefault();
            const t = e.touches[0];
            touchX = t.clientX;
            touchY = t.clientY;
            touchTime = Date.now();
            swiping = false;
            lastMove = 0;
        }, {passive: false});
        
        canvas.addEventListener('touchmove', (e) => {
            if (gameOver || startBtn.style.display !== 'none') return;
            e.preventDefault();
            
            const t = e.touches[0];
            const dx = t.clientX - touchX;
            const dy = t.clientY - touchY;
            const now = Date.now();
            
            if (now - lastMove < 16) return;
            lastMove = now;
            
            if (!swiping && dy > 40 && Math.abs(dy) > Math.abs(dx)) {
                swiping = true;
                hardDrop();
                draw();
            } else if (!swiping && dx < -25 && Math.abs(dx) > Math.abs(dy)) {
                swiping = true;
                moveLeft();
                draw();
                touchX = t.clientX;
                touchY = t.clientY;
                setTimeout(() => swiping = false, 100);
            } else if (!swiping && dx > 25 && Math.abs(dx) > Math.abs(dy)) {
                swiping = true;
                moveRight();
                draw();
                touchX = t.clientX;
                touchY = t.clientY;
                setTimeout(() => swiping = false, 100);
            }
        }, {passive: false});
        
        canvas.addEventListener('touchend', (e) => {
            if (gameOver || swiping || startBtn.style.display !== 'none') return;
            e.preventDefault();
            
            const t = e.changedTouches[0];
            const dx = t.clientX - touchX;
            const dy = t.clientY - touchY;
            const dur = Date.now() - touchTime;
            
            if (dur < 250 && Math.abs(dx) < 15 && Math.abs(dy) < 15) {
                rotate();
                draw();
            }
        }, {passive: false});
        
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            if (e.key === 'ArrowLeft') { e.preventDefault(); moveLeft(); }
            else if (e.key === 'ArrowRight') { e.preventDefault(); moveRight(); }
            else if (e.key === 'ArrowDown') { e.preventDefault(); hardDrop(); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); rotate(); }
            draw();
        });
        
        startBtn.onclick = function(e) {
            console.log('START BUTTON CLICKED!');
            e.stopPropagation();
            startGame();
        };
        
        startBtn.addEventListener('touchstart', function(e) {
            console.log('START BUTTON TOUCHED!');
            e.stopPropagation();
            e.preventDefault();
        }, {passive: false});
        
        startBtn.addEventListener('touchend', function(e) {
            console.log('START BUTTON TOUCH END!');
            e.stopPropagation();
            e.preventDefault();
            startGame();
        }, {passive: false});
        
        console.log('Event listeners attached, startBtn:', startBtn);
        
        pauseBtn.onclick = function() {
            paused = !paused;
            pauseBtn.textContent = paused ? '‚ñ∂' : 'II';
            if (!paused) {
                lastTime = performance.now();
                requestAnimationFrame(update);
            }
        };
        
        console.log('Calling initial draw...');
        draw();
        console.log('Initial draw complete');
    </script>
</body>
</html>
